---
title: "JS study: Scope"
categories: javascript
tags: ["javascript"]
---



# 💡 Scope

스코프는 식별자 (변수, 함수, 클래스)가 참조될 수 있는 범위, **식별자를 검색하는 규칙**을 의미한다. 이 범위는 코드 블록으로 구분되어져, {}로 감싸지는 함수, if나 switch 조건문, for 문 등으로 내부에 선언된 변수는 외부에서는 접근할 수 없는 특징을 가진다. **마치 썬팅된 자동차의 운전자는 외부를 볼 수 있지만 자동차 외부에서는 안을 볼 수 없는 것과 같다.** 



<img width="800" src="https://t1.daumcdn.net/cfile/tistory/2155063B527737B20C"/>



스코프 내의 변수는 유일해야하지만, 다른 스코프라면 같은 이름의 변수를 가질 수 있어, **이름 충돌을 막을 수 있고**, 블록 내부의 사용하지 않는 변수는 이후 GC(Garbage Collecotr) 에 의해 메모리에서 제거되어 **메모리를 절약할 수 있는** 장점을 갖는다.  



스코프는 크게 전역 스코프과 지역 스코프로 나눌 수 있으며, 전역 스코프에 선언된 변수는 어디서든 접근이 가능하고, 앱이 종료될 때까지 GC가 제거하지 않는 특징을 가진다. 지역 스코프는 앞서 설명했던 블록 내부를 의미하며 지역 스코프에서 선언된 변수는 지역스코프 내부와, 하위 스코프에서만 참조가 가능하다. (안에서 밖은 가능, 밖에서 안은 불가능)



``` javascript
const text = 'global'; //전역 변수, 전역 스코프
{
  const text = 'inside block1'; //로컬 변수, 로컬 스코프
  {
    const text = 'inside block2';
    console.log(text);//inside block2
  }
}

```



그럼 어떻게 javascript는 scope들의 관계를 알 수 있을까?



## ⛓ Scope 체인

스코프들의 **계층적인 연결**을 스코프 체인이라고 부른다. 변수를 참조할 때 스코프 체인을 이용해 변수를 참조하는 코드에서 시작해서, 변수를 찾을 수 없으면 상위 스코프로 이동해서 변수를 찾는다. 이런 스코프 체인이 가능한 것은 연결리스트와 같이 실제 자료구조인 **Lexical 환경**로 연결되어 있다. 

**Lexical 환경**에서 **전역 lexical 환경**은 코드가 로드되면 바로 생성되며, 함수의 경우 함수가 호출되면 생성된다.   스코프의 변수들을 key에 저장하고, 상위 스코프 정보를 저장한다. (자세한 내용은 이후 실행 컨텍스트를 정리하면서 더 자세히 정리하고자 한다)



아래의 예제에서 inner내부의 x,y,z를 찾는 과정을 보면 먼저 x는 inner 내부에 존재하기 때문에 바로 찾아 탐색을 정지한다. y는 inner내부에 없기 때문에 상위 스코프인 outer를 확인하지만 outer에도 없기 때문에 가장 상위인 전역 스코프에서 y를 찾고 탐색을 정지한다.

```javascript
const x = "global x"
const y = "global y"

function outer() { 
  function inner() {
    const x = "inner's local x";
    console.log(x);
    console.log(y);
  }
  inner();
}

outer();
```



## 📚 lexical scope

함수가 실행될 때 스코프를 어떻게 정의하느냐에 따라 결과가 달라질 수 있다. 두가지 방식이 있을 수 있는데, 첫번째는 동적 스코프로 함수를 어디에 호출하느냐에 따라 스코프가 결정되는 방식이다. 두번쨰로는 lexical 스코프, 정적 스코프로 **함수를 어디에 정의했느냐**에 따라 스코프가 결정된다. 

자바스크립트는 lexical scope을 기반으로 작동하기 때문에 어디에 함수를 호출하느냐가 중요한 게 아니라 함수를 정의한 곳이 기준이 되어 스코프가 정해진다.



```javascript
const x = 1;

function foo() {
  const x = 10;
  bar();
}

function bar() {
  console.log(x);
}

foo();
bar();

```

위 예시를 보면서 처음에 foo()에는 x=10이 나오지 않을까라는 생각을 했지만, foo와 bar 모두 동일하게 1로 콘솔에 찍혔다. 역시 그 이유는 함수가 호출되는 곳이 기준이 아니라 **함수가 정의되는 곳**이 기준으로 스코프가 결정되기 때문이다. bar는 foo내부에서 호출되었지만 전역에 선언된 함수이기 때문에 전역스코프를 가진다. 그렇기 때문에 x=1이 탐색되어 호출된다. 

(간단하네라고 생각했지만 막상 틀리니... 쉽다 생각한 내가 부끄러웠다)

