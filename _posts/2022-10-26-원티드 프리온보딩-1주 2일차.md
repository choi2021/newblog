---
title: "원티드 프리온보딩 1주차 첫째주 과제-best case찾기"
categories: 원티드프리온보딩
tags: ["eslint", "prettier", "Git Hook", "Husky", "협업 툴"]
---



# 사전 과제  정리



## 1. 폴더 구조

```
components/
  auth_form
  auth_input
  todo_btn
  todo_form
  todo_item

network/
  http.js
  httpError.js
  
pages/
  auth.jsx
  todo.jsx
  
service/
  auth.js
  todo.js
  
router.jsx
index.js
```


## 1.Auth

#### authService

authClass의 메소드들은 httpClient 클래스의 fetch함수를 이용해 url, header, body를 전달하는 클래스입니다.

```javascript
export class AuthService {
  constructor(httpClient) {
    this.httpClient = httpClient;
  }
  async postSignUp(email, password) {
    return this.httpClient.fetch('/auth/signup', {
      method: 'POST',
      body: JSON.stringify({
        email,
        password,
      }),
    });
  }

  async postSignIn(email, password) {
    return this.httpClient.fetch('/auth/signin', {
      method: 'POST',
      body: JSON.stringify({
        email,
        password,
      }),
    });
  }
}

```



#### httpClient

httpClient 클래스는 가지고 있는 baseURL에 전달받은 url과 option에 따라 fetch를 실행해주는 클래스입니다.

fetch는 성공했다면 JWT가 담긴 객체를 반환하고 실패했다면 커스텀 에러 HTTPError를 던지고 메시지를 전달합니다.

```javascript
export class HttpClient {
  constructor(baseURL) {
    this.baseURL = baseURL;
  }

  async fetch(url, options) {
    const res = await fetch(`${this.baseURL}${url}`, {
      ...options,
      headers: {
        'Content-Type': 'application/json',
        ...options.headers,
      },
    });
    try {
      if (!res.ok) {
        console.error(`${res.status}에러가 발생했습니다`);
        throw new HTTPError(res.status, res.statusText);
      } else {
        return await res.json();
      }
    } catch (e) {
      return e.codeToErrorMessage;
    }
  }
}

```



#### HTTPError

http에러는 에러메시지를 커스텀하기 위한 클래스로 전달받은 에러의 status_code에 따라 메시지를 반환해줍니다.

| 컴포넌트 | Status code      | 내용                             |
| :------: | ---------------- | -------------------------------- |
| 회원가입 | 400 Bad Request  | 동일한 이메일이 이미 존재합니다. |
|  로그인  | 401 Unauthorized | Unauthorized                     |
|  로그인  | 404 Not found    | 해당 사용자가 존재하지 않습니다. |
|   todo   | 400 Bad Request  | todo should not be empty         |



```javascript
export default class HTTPError extends Error {
  constructor(statusCode, message) {
    super(message);
    this.name = `HTTPError`;
    this.statusCode = statusCode;
  }

  get codeToErrorMessage() {
    let result = { message: '', success: false };
    switch (this.statusCode) {
      case 400:
        result = {
          message: '동일한 이메일이 이미 존재합니다.',
          success: false,
        };
        break;
      case 401:
        result = {
          message: '이메일 혹은 비밀번호를 확인해주세요.',
          success: false,
        };
        break;
      case 404:
        result = {
          message: '해당 사용자가 존재하지 않습니다.',
          success: false,
        };
        break;
      default:
        throw new Error('Unknown Error');
    }
    return result;
  }
}
```



class들로 각각을 나눠놓음으로써 api호출 시 httpClient에서는 코드중복을 줄일 수 있고, httpError에서 에러와 관련된 로직만 처리하면 되는 장점을 가질 수 있습니다.



이렇게 반환된 결과에서 성공하면 "access_token"을 회원가입,로그인 모두 전달 받기 때문에 성공여부를 "access_token"을 key로 하는 객체인지를 확인으로 합니다. 회원가입 성공시 성공했다는 메시지를,  로그인 성공시에는 로컬스토리지에 해당 토큰을 추가합니다. 



실패시에는 httpError로 전달받은 에러메시지를 message상태에 담아 UI로 어떤 에러인지 알려줍니다. 

```javascript

  const handleLoginSubmit = useCallback(
    async (info) => {
      const { email, password } = info;
      const response = await authService.postSignIn(email, password);
      if ('access_token' in response) {
        navigate('/todo');
        localStorage.setItem('access_token', response.access_token);
      } else {
        setLoginMessage((prev) => {
          return {
            ...prev,
            ...response,
          };
        });
      }
    },
    [navigate]
  );

  const handleRegisterSubmit = useCallback(async (info) => {
    const { email, password } = info;
    const response = await authService.postSignUp(email, password);
    let message = response;
    if ('access_token' in response) {
      message = {
        message: `회원가입에 성공했습니다`,
        success: true,
      };
    }
    setRegisterMessage((prev) => {
      return {
        ...prev,
        ...message,
      };
    });
  }, []);

```

![2](https://user-images.githubusercontent.com/80830981/195253337-c4965a85-d65a-4c5c-b08a-c0542e0315ed.gif)



## 4. Todo

todo페이지는 todo를 추가할 수있는 form과 todo들을 보여주는 list로 구성되어 있습니다.



```javascript
function Todo({ todoService }) {

    ...
 
  return (
    <S.TodoLayout>
      <header>TO DO</header>
      <S.TodoContent>
        <TodoForm onSubmit={handleSubmit} isBlank={isBlank}></TodoForm>
        <S.TodoList>
          {todos.map((item) => (
            <TodoItem
              key={item.id}
              todoItem={item}
              onUpdate={handleUpdate}
              onDelete={handleDelete}
            ></TodoItem>
          ))}
        </S.TodoList>
      </S.TodoContent>
    </S.TodoLayout>
  );
}

export default Todo;

```



## 4.1 상태

투두페이지가 가지는 상태와 todo_item이 가지는 개별적인 상태로 구분됩니다.

### 4.1.1 todo

todo페이지는 전체 투두들을 담는 todos와 todoForm이 비어있는지를 확인하는 isBlank라는 상태 두가지를 가지고 있습니다.

todos는 추가 삭제 변경되는 투두들을 저장하는 데이터이고, todo_form의 input의 내용이 비어진채로 보내면 400BadRequest 에러를 서버가 보내기 때문에 input이 비어있는지 true/false로 나타냅니다.



#### 4.1.2 todo_item

todo에 완료여부와 내용을 변경할 수 있게 onModifyMode, 업데이트된 내용을 중간에서 담아줄 updated, 내용이 비어있는지 확인해줄 isBlank세가지 상태를 가지고 있습니다.

![5](https://user-images.githubusercontent.com/80830981/195255554-22fab375-2ce5-42a5-862c-91e009107660.gif)

```javascript
//todo.jsx

const [todos, setTodos] = useState([]);
const [isBlank, setIsBlank] = useState(false);

//todo_item.jsx

  const [onModifyMode, setOnModifyMode] = useState(false);
  const [updated, setUpdated] = useState(todoItem);
  const [isBlank, setIsBlank] = useState(false);

```



### 4.2 함수

### 4.1.1 todo

todo페이지의 함수들은 투두의 CRUD를 위한 todoService 클래스의 메소드들을 이용합니다. todoService의 클래스는 httpClient를 이용해 api 호출을 합니다.

```javascript
export class TodoService {
  constructor(httpClient) {
    this.httpClient = httpClient;
  }
  async create(todo) {
    return this.httpClient.fetch('/todos', {
      method: 'POST',
      headers: {
        Authorization: `Bearer ${localStorage.getItem('access_token')}`,
      },
      body: JSON.stringify({
        todo,
      }),
    });
  }

  async get() {
    return this.httpClient.fetch('/todos', {
      method: 'GET',
      headers: {
        Authorization: `Bearer ${localStorage.getItem('access_token')}`,
      },
    });
  }

  async update(obj) {
    const { todo, isCompleted } = obj;
    return this.httpClient.fetch(`/todos/${obj.id}`, {
      method: 'PUT',
      headers: {
        Authorization: `Bearer ${localStorage.getItem('access_token')}`,
      },
      body: JSON.stringify({
        todo,
        isCompleted,
      }),
    });
  }

  async delete(id) {
    return this.httpClient.fetch(`/todos/${id}`, {
      method: 'DELETE',
      headers: {
        Authorization: `Bearer ${localStorage.getItem('access_token')}`,
      },
    });
  }
}

```



get: 지난 투두들을 불러올때는 useEffect를 이용해서 처음 렌더링때 받아옵니다.

post: 새롭게 투두를 추가할 때는 비어있지 않은지 확인 후에 서버의 todos와 UI의 todos에 추가 후, input안의 내용을 비웁니다.

delete: 전달받은 투두의 id를 이용해 서버와 UI의 투두를 제거합니다.

put: 수정된 todo를 전달받아 전달받은 todo의 id와 같은 todo로 map을 이용해 변경합니다.

```react
 useEffect(() => {
    todoService.get().then((todos) => {
      setTodos(todos);
    });
  }, []);

  const handleSubmit = async (e, ref) => {
    e.preventDefault();
    const value = ref.current.value;
    if (!value) {
      setIsBlank(true);
      return;
    }
    const newTodo = await todoService.create(value);
    setTodos((prev) => [...prev, newTodo]);
    ref.current.value = '';
    setIsBlank(false);
  };

  const handleDelete = useCallback((id) => {
    setTodos((prev) => prev.filter((todo) => todo.id !== id));
    todoService.delete(id);
  }, []);

  const handleUpdate = useCallback((todo) => {
    setTodos((prev) =>
      prev.map((item) => {
        if (item.id === todo.id) {
          return todo;
        }
        return item;
      })
    );
    todoService.update(todo);
  }, []);
```



### 4.1.2 todoItem

todoItem은 수정모드를 on/off하는 handleClick함수와 완료여부를 담을 수 있는 handleCompleteUpdate, 변경된내용을 api호출하는 handleSubmit가 있습니다.

```react
  const handleClick = useCallback((e) => {
    const { name } = e.currentTarget;
    if (name === 'cancel') {
      inputRef.current.value = ``;
    }
    setOnModifyMode((prev) => !prev);
  }, []);


  const handleCompleteUpdate = useCallback((e) => {
    const { name } = e.currentTarget;
    if (name === 'complete') {
      setUpdated((prev) => {
        return { ...prev, isCompleted: true };
      });
    } else {
      setUpdated((prev) => {
        return { ...prev, isCompleted: false };
      });
    }
  }, []);

  const handleSubmit = useCallback(() => {
    const todo = inputRef.current.value;
    if (!todo) {
      setIsBlank(true);
      return;
    }
    onUpdate({ ...updated, todo });
    inputRef.current.value = ``;
    setOnModifyMode((prev) => !prev);
    setIsBlank(false);
  }, [onUpdate, updated]);

```





