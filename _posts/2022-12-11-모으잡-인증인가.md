---
title: "모으잡-SSR을 이용한 인증,인가 도입"
categories: 모으잡
tags: ["project", "모으잡"]
---

# 🔓 SSR을 이용한 인증/인가 도입

이번에 프로젝트를 고민하면서 항상 답답했던 부분이었던 페이지 redirection과 user상태 관리에 대해 더 깊이 공부했다. CSR로 관리하던 user상태를 SSR로 수정하기까지 과정을 정리해 보려 한다.



## 😅 Firebase의 onAuthStateChanged를 이용한 User 상태 관리

기존 Authentication은 firebase Auth를 이용해 받아온 user정보의 token을 localstorage에 저장해서 확인했다. firebase를 공부하면서 firebase Auth의 API인 onAuthStateChanged가 있다는 것을 알게 되었고, API를 이용한다면 별도의 토큰과 쿠키를 저장하지 않아도 될 것이란 예상이 되어 적용했다.   

```tsx
//AuthService.ts
export class AuthServiceImpl implements AuthService {
  googleProvider: GoogleAuthProvider;
  githubProvider: GithubAuthProvider;
  auth: Auth;

  constructor(private app: FirebaseApp) {
    this.googleProvider = new GoogleAuthProvider();
    this.githubProvider = new GithubAuthProvider();
    this.auth = getAuth(this.app);
  }
    ...
  onUserStateChanged(callback: Dispatch<SetStateAction<User | null>>) {
    return onAuthStateChanged(this.auth, callback);
  }
}

//AuthContext.tsx

type InitialValue = {
  authService: AuthService;
  user: User | null;
};

const AuthContext = createContext<InitialValue | null>(null);
export const AuthProvider = ({ children, authService }: AuthProviderProps) => {
  const [user, setUser] = useState<User | null>(null);
  useEffect(() => {
    authService.onUserStateChanged((user) => {
      setUser(user);
    });
  }, []);

  return (
    <AuthContext.Provider value={{ user, authService }}>
      {children}
    </AuthContext.Provider>
  );
};

export const useAuthService = () => {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('Not under AuthProvider');
  }
  return context;
};

```



이렇게 수정하고 API를 이용해 login상태를 확인해서 페이지 이동을 하다 보니 다른 문제가 생겼다. 랜더링을 하고 API로 user상태를 바꾸기 전, 초기 값이 null로 되어있어 react-Query로 API 호출시 **user가 없는 상태로 호출**되어 에러가 나타났다. react query를 이용해 API를 받아올 때 userId가 필요하기 때문에 발생한 에러였기 때문에 우선 useJobs 훅 내부에서 user상태가 달라지면 refetch해 받아와 해결했다. 

```typescript
export const useSpecificJobs = () => {
  const { user } = useAuthService();
  const { query } = useRouter();
  const { id } = query;
  const dbService = useDBService();

  const getFilteredJobs = useQuery(
    [JOBS_KEY],
    () => {
      if (!user) {
        return {};
      }
      return dbService.getJobs(user);
    },
    {
      select: (data: ModifiedJobsType) => {
        if (!data) {
          return [];
        }
        return Object.values(data).filter((item) => item.id !== id);
      },
      onError: (error) => {
        console.log(error);
      },
    }
  );
  useEffect(() => {
    getFilteredJobs.refetch();
  }, [user]);
	...
};
```



하지만 이전 채용공고들을 받아오기 까지 과정이 1) 메인 페이지 렌더링-> 2) react Query API호출 -> 3) User상태 업데이트-> 4) reactQuery API 호출로 **같은 API를 두번 호출하는 과정에서 시간이 더 오래 걸리게 되었다**. 해결 방법으로 user를 받은 후에 API콜이 일어나게 할 방법이 없을까, auth를 server-side로 먼저 받아올 수는 없을까라는 고민이 들었다. 이런 페이지 이동과 인증/인가는 항상 프로젝트를 하면서 발목을 잡았던 부분이기 때문에 관련 자료를 찾아 공부하는 게 우선이라는 생각이 들었다. 



## 💻 CSR에서의 해결법: Protected Route 도입

### 1) 로그인 flow 수정하기

먼저 가장 시급한 문제는 로그인 후에 메인 페이지 이동시에 User가 없는 상태로 API가 호출된다는 점이었다. 이것을 막기 위해서는 먼저 user상태를 관리해줄 수 있는 component가 필요했고, AuthStateChanged라는 컴포넌트를 만들어 컴포넌트가 마운트되면 User를 받아오고, 이후에 메인페이지가 렌더링 될 수 있게 했다.

```tsx
// AuthStateChanged.tsx

import React, { useEffect, useState } from 'react';
import { useAuthService } from '../context/AuthContext';

export default function AuthStateChanged({
  children,
}: {
  children: React.ReactNode;
}) {
  const { authService, setUser } = useAuthService();

  const [loading, setLoading] = useState(true);
  useEffect(() => {
    authService.onUserStateChanged((user) => {
      setUser(user);
      setLoading(false);
    });
  }, []);

  if (loading) {
    return <h1>로딩중</>;
  }

  return <>{children}</>;
}

// _app.tsx
    
function MyApp({ Component, pageProps }: AppProps) {
    ...
  return (
    <>
      <QueryClientProvider client={queryClient}>
        <DBProvider dbService={dbService}>
          <AuthProvider authService={authService}>
            <AuthStateChanged>
              <ThemeProvider theme={theme}>
                <GlobalStyle />
                <Component {...pageProps} />
              </ThemeProvider>
            </AuthStateChanged>
          </AuthProvider>
        </DBProvider>
      </QueryClientProvider>
    </>
  );
}
export default MyApp;
 
```

User가 있어야만 다음 컴포넌트들로 넘어가 동작하기 때문에 이전 가장 큰 문제였던 1) 메인 페이지 렌더링-> 2) react Query API호출 -> 3) User상태 업데이트-> 4) reactQuery API 호출 순서에서 정상적으로 1) 메인 페이지 렌더링-> 2) User상태 업데이트-> 3) reactQuery API 호출로 수정할 수 있다. 덕분에 정상적으로 문제없이 react-query API들을 사용할 수 있었다.

하지만 여전히 살짝 문제가 남아있었던 것은 AuthStateChanged에서 User를 받아오는 동안 **화면에 로딩을 보여줘야한다**는 점이었다. 로딩을 안보여주기 위해 loading이 true일 때 `<></>` 리액트 fragment로 반환한다해도 여전히 불러오는 동안의 빈페이지가 보였다.



[AuthStateChanged 컴포넌트를 추가한 후 새로고침한 모습]

<img src="/assets/img/2022-12-11-모으잡-인증인가/ezgif.com-gif-maker (1).gif" width="700" />



### 2) Protected Route

두번째로 로그인하지 않고 메인페이지에 접속하는 경우와 로그인 후에도 로그인 페이지에 접속하려는 경우를 막기 위한 redirection로직이 필요했다. 이것을 위해서 AuthStateChanged 컴포넌트와 유사하게 조건에 따라 랜더링을 해줄 수 있는 ProtectedRoutes 컴포넌트를 추가했다. Protected Route는 필요한 페이지에 맞게 사용되어야 했기 때문에 type을 정할 때 Generic으로 정해줄 수 있었다.



```tsx
//ProtectRoute.tsx

import { useRouter } from 'next/router';
import React, { ComponentType } from 'react';
import { useAuthService } from '../context/AuthContext';
export function withPublic<T>(Component: ComponentType<T>) {
  return function WithPublic(props: T) {
    const auth = useAuthService();
    const router = useRouter();
    if (auth.user) {
      router.replace('/');
      return <></>;
    }
    return <Component auth={auth} {...props} />;
  };
}

export function withProtected<T>(Component: React.ComponentType<T>) {
  return function WithProtected(props: T) {
    const auth = useAuthService();
    const router = useRouter();
    if (!auth.user) {
      router.replace('/login');
      return <></>;
    }
    return <Component auth={auth} {...props} />;
  };
}

// pages/login.tsx
function Login() {
	...
}
    
export default withPublic(Login);

// Pages/register.tsx
function Register() {
  ...
}

export default withPublic(Register);

    
// pages/index.tsx
function Home() {
	 ...
}

export default withProtected(Home);

// pages/job/[id].tsx

function Index() {
 	...
}

export default withProtected(Index);


```

Protected Route를 이용해 home에서 login으로 이동하거나 login에서 home으로 url을 이용한 이동을 막을 수 있었다. 하지만 여전히 앞서 문제가 되었던 페이지 이동까지 시간동안 **로딩을 보여줘야하는 문제**가 있었다. 똑같이 React.Fragment로 빈페이지로 보여줘도 되지만, Protected Routes를 알기전에 해결방법으로 떠올렸던 **서버사이드**에서 auth를 미리 받아와서 렌더링전에 페이지 이동을 시키고, 해당 페이지에서 auth를 바로 받아볼 수 있다면 좀 더 로직도 간단해지고, next를 잘 활용하는 방법이 되지않을까라는 생각이 들었다.



## 💾 SSR로 전환





