---
title: "Class: 객체를 만드는 template"
categories: javascript
tags: [javascript, 문법]
---

## 1. 생성자함수

어제 함수에 대해 정리하면서 생성자 함수는 정리하지 않았다. 그 이유는 생성자함수는 오브젝트를 반환하는, 새로운 객체를 만들 수 있는 함수로 클래스와 같은 기능을 하기 때문이다. 다음의 코드를 보자

```javascript
function Dog(name, owner) {
  this.name = name;
  this.owner = owner;
  this.play = () => {
    console.log("놀기");
  };
  //  return this
}

const dog = new Dog("봄이", "영준");
console.log(dog); //Dog { name: '봄이', owner: '영준', play: [Function (anonymous)] }
```

Dog 함수는 이름과 주인을 받아서 새로운 객체에 전달해주고 play()라는 메소드를 전달한 뒤 객체를 반환하는 함수이다. 이때 this는 new를 통해 만들어진 오브젝트를 의미하며 내부에서 해당 오브젝트를 가리킬 때 붙여줘야 한다 (this도 너무 중요해서 이후에 자세히 정리해볼 예정이다). 생성자 함수에서는 return this를 하지 않아도 자바스크립트가 자동으로 반환해줘서 생략이 가능하다. 이러한 생성자 함수를 통해 오브젝트를 사용할 수 있지만 객체를 만드는 다른 방법이 있는데 그것이 바로 <b>클래스</b>이다.

## 2. 클래스(Class)

클래스는 객체지향언어에서 있던 문법으로 자바스크립트에는 원래 없었으나 추가된 문법이다. 원래 자바스크립트의 생성자함수는 prototype을 이용해서 객체를 만들었기에, 여기에 클래스 문법을 더해 외부적으로는 개발자들이 class를 이용해서 객체를 만들 수 있고, 내부적으로는 prototype을 통해서 객체가 만들어진다. 이를 <b>Synthetic Sugar</b>, 편리함을 위해 추가된 문법이라고 부른다.

```javascript
class Dog {
  constructor(name, owner) {
    this.name = name;
    this.owner = owner;
  }
  play = () => {
    console.log("놀기");
  };
}

const dog = new Dog("봄이", "영준");
console.log(dog); //Dog { name: '봄이', owner: '영준', play: [Function (anonymous)] }
```

![img](https://velog.velcdn.com/images/seunghw/post/b3187a8b-685a-4054-af8a-7b544342f5df/image.png)

[출처:https://velog.io/@seunghw/%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-1-JavaScript]

class는 새로운 객체를 만드는 틀로, class를 통해 만들어 진 객체를 <b>instance</b>라고 부른다. 위 코드에서 사용된 constructor 함수는 instance가 만들어질 때 호출되는 함수로 constructor 함수에 전달된 인자들은 name과 owner속성으로 instance에 자동으로 추가된다. method에 해당하는 play는 생성자함수에서와는 다르게

this를 떼고 함수 이름을 통해 전달할 수 있다.

### 2.1) static 속성

class에는 class 자체가 가지는 속성과 행동이 있고 instance가 가지는 속성과 메소드가 있다. 이때 class 자체가 가지는 속성과 행동을 <b>static 속성</b>이라고 부르며 class의 이름을 통해 호출할 수 있다. 다음 코드를 살펴보자.

```javascript
class Dog {
  static OWNER = "Choi"; //class 레벨
  static sleep() {
    console.log("자기"); //class 레벨
  }
  constructor(name, gender) {
    this.name = name; //instance 레벨
    this.gender = gender; //instance 레벨
  }
  play = () => {
    //instance 레벨
    console.log("놀기");
  };
}

const dog1 = new Dog("봄이", "male");
console.log(dog1); //Dog { name: '봄이',gender:"male", play: [Function (anonymous)] }
console.log(Dog.OWNER); //Choi
Dog.sleep(); //자기

console.log(Math.abs(-2)); //2
```

위에 class를 통해 객체를 만들 때 함께 만들어지는 속성과 메소드를 "instance 레벨의 속성과 메소드"라고 부르며 instance에 따라 달라지지 않고, 객체에 상관없이 모두 동일한 속성이나 메소드가 필요할 때 <b>static</b>키워드를 앞에 붙여주면 class 레벨의 속성과 메소드가 되어 class를 통해 호출이 가능하다. 이러한 예로는 자주 사용하는 Math 빌트인 객체가 있다. Math를 사용할 때 new를 이용해 객체를 만들지 않고도 사용할 수 있게 static속성과 메소드가 되어있어 바로 사용할 수 있다.

## 2.2) Field와 접근 제어자

Field는 class 내부에 포함된 변수를 의미하며 위에 언급한 static 속성의 경우는 class변수이고, instance변수로는 constructor함수를 통해 만들거나 다음과 같이 class 내부에 변수를 선언해 만들 수 있다. 이러한 변수들은 접근 가능한 정도에 따라 세 가지로 나뉠 수 있다.

1. public: 접근, 수정 가능
2. private: class내부에서만 접근, 수정 가능
3. protected: 상속된 자식에서 접근, 수정 가능

```javascript
class Dog {
  species = "Retriever"; //instance 레벨
  static OWNER = "Choi"; //class 레벨
  constructor(name) {
    this.name = name; //instance 레벨
  }
  play = () => {
    //instance 레벨
    console.log("놀기");
  };
}

const dog1 = new Dog("봄이");
console.log(dog1); //Dog { name: '봄이', play: [Function (anonymous)] }
console.log(dog1.species); //dog

console.log(Dog.OWNER); //Choi
```

이때 class를 이용해 속성과 메소드를 만들고 나서 사용자가 수정해버릴 수도 있고, 내부의 값을 보여주고 싶지 않을 수도 있다. 이를 위해 <b>접근 제어자</b>라는 속성을 이용해 public상태에서 private상태로 변환해 준다. 제어하고 싶은 속성에 "#"을 붙여서 사용할 수 있다. 예시 코드에서 Dog 클래스에서 마음대로 species, 이름을 바꿔서는 안되므로 접근 제어자로 제어해보자

```javascript
class Dog {
  #name;
  #species = "dog";
  constructor(name) {
    this.#name = name;
  }
  play = () => {
    console.log("놀기");
  };
  getInfo() {
    return `name:${this.#name} species:${this.#species}`;
  }
}

const dog = new Dog("봄이", "male");
console.log(dog); //Dog { play: [Function: play] }
console.log(dog.species); //undefined
console.log(dog.getInfo()); //name:봄이 species:dog
console.log(dog.#species); //error
```

constructor함수로 전달될 변수는 constructor 밖에서 private으로 속성을 선언한 후에 값을 전달해 주어야 하며, private 속성을 보여줄 수 있는 함수 getInfo를 통해 보여 줄 수 있다.

## 2.3) Getter와 Setter

Getter와 Setter는 접근자 속성으로 함수를 일반 속성처럼 사용할 수 있게 해 준다. 다음 예시를 통해 알아보자.

```javascript
class TestScore {
  constructor(math, english) {
    this.math = math;
    this.english = english;
  }
  averageScore() {
    return (this.math + this.english) / 2;
  }
}

const test1 = new TestScore(100, 90);
console.log(test1.averageScore()); //함수를 이용해야해
```

TestScore라는 class에 과목 점수를 전달하고 평균값을 알고 싶을 때 호출해야 하는 건 속성이 아니라 함수이다. 해결하고 싶어서 constructor값으로 전달하게 되면 처음 만들 전달된 값으로 고정되기 때문에 점수가 바뀌었을 때 업데이트가 될 수 없다.

```javascript
class TestScore{
    constructor(math,english){
        this.math=math;
        this.english=english
        this.averageScore=(this.math+this.english)/2
    }

}

const test1 = new TestScore(100, 90);
console.log(test1.averageScore; //95.0
test1.math=85;
console.log(test1.averageScore);//95.0
```

위에 예제의 averageScore는 87.5점이 되어야 하지만 여전히 95점으로 나타난다. 이를 해결하기 위해 사용할 수 있는 게 <b>Getter와 Setter</b>이다.

Getter는 속성 값을 불러올 때 사용되는 함수이고 Setter는 속성값을 바꿀 때 호출되는 함수이다. 예시 코드를 getter와 setter를 통해 수정하면 다음과 같다.

```javascript
class TestScore {
  constructor(math, english) {
    this.math = math;
    this.english = english;
  }
  get averageScore() {
    return (this.math + this.english) / 2;
  }
  set averageScore(value) {
    this.averageScore = value;
  }
}

const test1 = new TestScore(100, 90);
console.log(test1.averageScore);
test1.math = 85;
console.log(test1.averageScore);
test1.averageScore = 70;
```



여기서 중요한 점은 setter를 사용할 때이다. 값을 바로 전달해주면 다음과 같은 에러가 발생한다.



![error](/assets/img/2022-09-15-class/error.png)



setter함수에 값을 전달해주고 값을 set해줄 때 또다시 값을 setter함수를 호출 하기 때문에 계속해서 반복해서 호출되는 무한 루프를 만들고 다음과 같이 call 스택이 다 차는 에러가 발생한다. 이를 해결하기 위해 다음과 같이 코드를 수정해 주어야 한다.

```javascript
class TestScore {
  constructor(math, english) {
    this.math = math;
    this.english = english;
  }
  get averageScore() {
    if (!this._averageScore) {
      this._averageScore = (this.math + this.english) / 2; // 처음 값이 undefined이므로
    }
    return this._averageScore;
  }

  set averageScore(value) {
    this._averageScore = value;
  }
}

const test1 = new TestScore(100, 90);
console.log(test1.averageScore); //95
test1.math = 85;
console.log(test1.averageScore); //87.5
test1.averageScore = 35;
console.log(test1.averageScore); //35
```

this.averageScore속성을 그대로 사용하지 않고 <b>this.\_averageScore</b>을 이용해 값을 저장하고 반환하게 함으로써 콜스택 에러를 해결할 수 있다.

### 2.4) 상속

두 class가 서로 공통되는 부분을 가질 때 반복하지 않고, 공통되는 class를 만들어 공통 class를 이용해 두 class를 만들 수 있다. 이러한 관계를 <b>상속</b>이라고 부른다.

```javascript
class LabTop {
  constructor(size, weight) {
    this.size = size;
    this.weight = weight;
  }
  showScreen() {
    console.log("화면 보여주기");
  }
  carry() {
    console.log("들수 있어");
  }
}

class DeskTop {
  constructor(size, weight, price) {
    this.size = size;
    this.weight = weight;
    this.price = price;
  }
  showScreen() {
    console.log("화면 보여주기");
  }
}
```

LabTop class와 DeskTop class는 size,weight속성과 showScreen이라는 메소드를 공통으로 가지고 있다. 이런 공통된 부분을 상속을 통해 나타내면 다음과 같이 나타낼 수 있다.

class LabTop{
constructor(size,weight){
this.size=size
this.weight=weight
}
showScreen(){
console.log("화면 보여주기")
}
carry(){

```javascript
class Computer {
  constructor(size, weight) {
    this.size = size;
    this.weight = weight;
  }
  showScreen() {
    console.log("화면 보여주기");
  }
}

class LabTop extends Computer {
  carry() {
    console.log("들수 있어");
  }
}

class DeskTop extends Computer {
  constructor(size, weight, price) {
    super(size, weight);
    this.price = price;
  }
  showScreen() {
    super.showScreen();
    console.log("듀얼로 보여주기");
  }
}

const lab1 = new LabTop(100, 100);
console.log(lab1);
lab1.carry();
lab1.showScreen();

const desk1 = new DeskTop(100, 100, 300);
console.log(desk1);
desk1.showScreen();
```

위에 예시에서 공통되었던 부분들은 모두 Computer라는 class에 속성과 메소드를 정리하고 각각 다른 부분만 추가적으로 정리해주었다. LabTop class는 carry() 메소드만 추가했고, DeskTop class에는 constructor함수 내에서 size와 weight은 상속하고 있는 Computer class에 전달해 주어야 하기에 <b>super</b>를 이용해 넘겨주었고, showScreen()함수에 상속 받은 내용은 <b>super.showScreen()</b>으로 연결해주고 추가적인 내용을 적어줌으로써 over-writting도 가능했다.

### 마치며

클래스는 생각보다 정리할 내용이 많아 오래 걸렸다. 그만큼 내 머릿속에서 모호했던 부분이 많았기에 정리하면서 class를 어떻게 사용할지 더 복습을 할 수 있었다.
